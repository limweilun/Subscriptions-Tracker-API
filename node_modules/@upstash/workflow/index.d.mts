import { R as RouteFunction, W as WorkflowServeOptions, E as ExclusiveValidationOptions, N as NotifyResponse, a as Waiter, S as Step } from './types-Cuqlx2Cr.mjs';
export { A as AsyncStepFunction, C as CallResponse, q as CallSettings, D as Duration, k as FailureFunctionPayload, F as FinishCondition, H as HeaderParams, L as LogLevel, o as NotifyStepResponse, P as ParallelCallState, j as PublicServeOptions, g as RawStep, l as RequiredExceptFields, i as StepFunction, f as StepType, e as StepTypes, h as SyncStepFunction, T as Telemetry, p as WaitEventOptions, m as WaitRequest, n as WaitStepResponse, c as WorkflowClient, b as WorkflowContext, s as WorkflowLogger, r as WorkflowLoggerOptions, d as WorkflowReceiver } from './types-Cuqlx2Cr.mjs';
import { Client as Client$1, QstashError } from '@upstash/qstash';
import 'zod';
import 'ai';
import '@ai-sdk/openai';

/**
 * Creates an async method that handles incoming requests and runs the provided
 * route function as a workflow.
 *
 * @param routeFunction - A function that uses WorkflowContext as a parameter and runs a workflow.
 * @param options - Options including the client, onFinish callback, and initialPayloadParser.
 * @returns An async method that consumes incoming requests and runs the workflow.
 */
declare const serve: <TInitialPayload = unknown, TRequest extends Request = Request, TResponse extends Response = Response>(routeFunction: RouteFunction<TInitialPayload>, options?: Omit<WorkflowServeOptions<TResponse, TInitialPayload>, "useJSONContent" | "schema" | "initialPayloadParser"> & ExclusiveValidationOptions<TInitialPayload>) => {
    handler: (request: TRequest) => Promise<TResponse>;
};

type ClientConfig = ConstructorParameters<typeof Client$1>[0];
/**
 * Workflow client for canceling & notifying workflows and getting waiters of an
 * event.
 *
 * ```ts
 * import { Client } from "@upstash/workflow";
 * const client = new Client({ token: "<QSTASH_TOKEN>" })
 * ```
 */
declare class Client {
    private client;
    constructor(clientConfig: ClientConfig);
    /**
     * Cancel an ongoing workflow
     *
     * Returns true if workflow is canceled succesfully. Otherwise, throws error.
     *
     * There are multiple ways you can cancel workflows:
     * - pass one or more workflow run ids to cancel them
     * - pass a workflow url to cancel all runs starting with this url
     * - cancel all pending or active workflow runs
     *
     * ### Cancel a set of workflow runs
     *
     * ```ts
     * // cancel a single workflow
     * await client.cancel({ ids: "<WORKFLOW_RUN_ID>" })
     *
     * // cancel a set of workflow runs
     * await client.cancel({ ids: [
     *   "<WORKFLOW_RUN_ID_1>",
     *   "<WORKFLOW_RUN_ID_2>",
     * ]})
     * ```
     *
     * ### Cancel workflows starting with a url
     *
     * If you have an endpoint called `https://your-endpoint.com` and you
     * want to cancel all workflow runs on it, you can use `urlStartingWith`.
     *
     * Note that this will cancel workflows in all endpoints under
     * `https://your-endpoint.com`.
     *
     * ```ts
     * await client.cancel({ urlStartingWith: "https://your-endpoint.com" })
     * ```
     *
     * ### Cancel *all* workflows
     *
     * To cancel all pending and currently running workflows, you can
     * do it like this:
     *
     * ```ts
     * await client.cancel({ all: true })
     * ```
     *
     * @param ids run id of the workflow to delete
     * @param urlStartingWith cancel workflows starting with this url. Will be ignored
     *   if `ids` parameter is set.
     * @param all set to true in order to cancel all workflows. Will be ignored
     *   if `ids` or `urlStartingWith` parameters are set.
     * @returns true if workflow is succesfully deleted. Otherwise throws QStashError
     */
    cancel({ ids, urlStartingWith, all, }: {
        ids?: string | string[];
        urlStartingWith?: string;
        all?: true;
    }): Promise<{
        cancelled: number;
    } & {
        error?: string;
    }>;
    /**
     * Notify a workflow run waiting for an event
     *
     * ```ts
     * import { Client } from "@upstash/workflow";
     *
     * const client = new Client({ token: "<QSTASH_TOKEN>" })
     * await client.notify({
     *   eventId: "my-event-id",
     *   eventData: "my-data" // data passed to the workflow run
     * });
     * ```
     *
     * @param eventId event id to notify
     * @param eventData data to provide to the workflow
     */
    notify({ eventId, eventData, }: {
        eventId: string;
        eventData?: unknown;
    }): Promise<NotifyResponse[]>;
    /**
     * Check waiters of an event
     *
     * ```ts
     * import { Client } from "@upstash/workflow";
     *
     * const client = new Client({ token: "<QSTASH_TOKEN>" })
     * const result = await client.getWaiters({
     *   eventId: "my-event-id"
     * })
     * ```
     *
     * @param eventId event id to check
     */
    getWaiters({ eventId }: {
        eventId: string;
    }): Promise<Required<Waiter>[]>;
    /**
     * Trigger new workflow run and returns the workflow run id
     *
     * ```ts
     * const { workflowRunId } = await client.trigger({
     *   url: "https://workflow-endpoint.com",
     *   body: "hello there!",         // Optional body
     *   headers: { ... },             // Optional headers
     *   workflowRunId: "my-workflow", // Optional workflow run ID
     *   retries: 3                    // Optional retries for the initial request
     * });
     *
     * console.log(workflowRunId)
     * // wfr_my-workflow
     * ```
     *
     * @param url URL of the workflow
     * @param body body to start the workflow with
     * @param headers headers to use in the request
     * @param workflowRunId optional workflow run id to use. mind that
     *   you should pass different workflow run ids for different runs.
     *   The final workflowRunId will be `wfr_${workflowRunId}`, in
     *   other words: the workflow run id you pass will be prefixed
     *   with `wfr_`.
     * @param retries retry to use in the initial request. in the rest of
     *   the workflow, `retries` option of the `serve` will be used.
     * @returns workflow run id
     */
    trigger({ url, body, headers, workflowRunId, retries, }: {
        url: string;
        body?: unknown;
        headers?: Record<string, string>;
        workflowRunId?: string;
        retries?: number;
    }): Promise<{
        workflowRunId: string;
    }>;
}

/**
 * Error raised during Workflow execution
 */
declare class WorkflowError extends QstashError {
    constructor(message: string);
}
/**
 * Raised when the workflow executes a function successfully
 * and aborts to end the execution
 */
declare class WorkflowAbort extends Error {
    stepInfo?: Step;
    stepName: string;
    /**
     * whether workflow is to be canceled on abort
     */
    cancelWorkflow: boolean;
    /**
     *
     * @param stepName name of the aborting step
     * @param stepInfo step information
     * @param cancelWorkflow
     */
    constructor(stepName: string, stepInfo?: Step, cancelWorkflow?: boolean);
}

export { Client, ExclusiveValidationOptions, NotifyResponse, RouteFunction, Step, Waiter, WorkflowAbort, WorkflowError, WorkflowServeOptions, serve };
